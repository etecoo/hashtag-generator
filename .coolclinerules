# Context Preservation Rules

## 1. プロジェクト初期化ルール

### 1.1 新規プロジェクトの初期化
新規プロジェクト検出時、以下のドキュメント構造を自動生成：
```
docs/
├── active/
│   ├── CONTEXT.md     # 現在のセッションの文脈情報
│   └── CURRENT.md     # 進行中のタスク管理
├── core/
│   └── CORE.md        # プロジェクト構造と重要な設定
├── technical/
│   ├── ADR.md         # アーキテクチャ決定記録
│   └── DESIGN.md      # 設計文書
└── history/
    ├── CHANGELOG.md   # 変更履歴
    └── ISSUES.md      # 問題と解決策の記録
```

### 1.2 既存プロジェクトの分析と構造化
既存プロジェクトを開いた際の自動処理：

1. **プロジェクト分析**
   - 既存のディレクトリ構造の確認
   - 不足しているドキュメントの特定
   - 既存のドキュメントがある場合はその構造を維持

2. **履歴情報の抽出**
   - Gitコミット履歴からの変更情報抽出
   - 既存のIssueやPRからの問題解決履歴抽出
   - プロジェクトの重要なマイルストーン特定

3. **ドキュメント構造の段階的構築**
   - 不足しているディレクトリの作成
   - 必要なドキュメントファイルの生成
   - 既存の情報の適切な配置

4. **既存情報の統合**
   - コミット履歴からCHANGELOG.mdの初期内容生成
   - Issue/PR履歴からISSUES.mdの初期内容生成
   - プロジェクト構造からCORE.mdの初期内容生成

### 1.3 初期ドキュメントテンプレート
- CORE.md: プロジェクト概要、構造、依存関係
- CONTEXT.md: セッション単位の文脈管理
- CURRENT.md: タスク進行状況の追跡
- CHANGELOG.md: セマンティックバージョニングに基づく変更記録
- ISSUES.md: 問題追跡と解決プロセスの記録
- ADR.md: アーキテクチャ決定の記録
- DESIGN.md: システム設計の詳細

## 2. 文脈保持の基本方針
- トークン消費を最小限に抑制すること
- 文脈の継続的な保持を重視すること
- エラー解決プロセスを詳細に記録すること
- プロジェクト構造の情報はCORE.mdに集約すること
  * ディレクトリ構造と役割
  * 重要なファイルの説明
  * 依存関係の概要
  * ドキュメント管理方針

## 3. ドキュメント更新ルール
- 基本ルールとして、ドキュメント更新の際は既存のものを勝手に削除してはならない
- 過去の記録に誤りがあったり、必要となる場合のみ過去の情報の改変や削除を行う
- また、"変更がないため省略"という対処も許さない
- 新しい記録を既存のものに足していくという姿勢を全てのファイルに対して維持

### 3.1 CONTEXT.md
- セッション単位での文脈管理
- タスクに必要な最小限の情報のみを保持
- セッション終了時に重要な情報をCORE.mdに統合
- 更新タイミング
  * 新しいセッション開始時
  * タスクの文脈変更時
  * デバッグ情報の追加時

### 3.2 CURRENT.md
- タスクの進行状況管理
- 試行錯誤の過程の記録
- 更新タイミング
  * タスク開始時
  * 進捗状況の変更時
  * タスク完了時

### 3.3 CORE.md
- 更新タイミング
  * プロジェクト構造の変更時
  * 重要なファイルの追加・削除時
  * 依存関係の変更時
  * ドキュメント管理方針の変更時

### 3.4 CHANGELOG.md
- 以下の変更を必ず記録すること
  * アーキテクチャの変更
  * 主要なバグ修正の影響範囲
  * 設定変更の背景
- 記録項目
  * 変更の背景と理由
  * ビジネスインパクト
  * 技術的な判断根拠
- Source Control連携
  * 関連するPR番号を記載 (例: PR #123)
  * 重要なコミットハッシュを記録
  * 関連するIssue番号への参照
  * 大規模な変更の場合はブランチ名も記録

### 3.5 ISSUES.md
#### Issue管理の基本方針
1. ファイル構造
   ```
   docs/history/
   ├── ISSUES.md             # アクティブな問題
   └── issues/              # アーカイブされた問題
       └── archive-YYYY-MM-DD-partN.md
   ```

2. アーカイブ基準
   - 完全に解決され、検証が完了したIssue
   - 現在のアクティブな問題の文脈理解に直接必要ないIssue
   - 将来の参照用として保存する価値があるIssue

3. アーカイブのタイミング
   - 関連する一連のIssueがすべて解決された時
   - Issue数が多くなり、ファイルの可読性が低下する時
   - プロジェクトの重要なマイルストーン到達時

4. アーカイブの手順
   - 新規アーカイブファイル作成（7-10 Issue程度でパート分割）
   - 完全な内容をアーカイブファイルに移動
   - ISSUES.mdに参照情報を追加
   - 関連するIssue間の参照を更新

5. 文脈の保持
   - アーカイブ→アクティブ、アクティブ→アーカイブの相互参照
   - 参照形式: `[ISSUE-NNN](issues/archive-YYYY-MM-DD-partN.md#issue-nnn)`
   - Issue間の関連性の明示的な記録

#### Issue記録の構造化
- Issue識別子
  * 形式: `[ISSUE-NNN] - YYYY-MM-DD`
  * NNNは連番（001から開始）
  * 日付は記録開始日

- 基本構造
  ```markdown
  ## [ISSUE-NNN] - YYYY-MM-DD
  ### タイトル
  #### 問題
  - 問題の概要
  - 発生状況
  - 影響範囲

  #### 対応策
  1. 実施する対策
  2. 検証方法
  3. 期待される結果

  #### 状態
  - [ ] 実装待ち
  - [ ] テスト待ち
  ```

- エラー情報の記録
  * エラーメッセージ全文
  * 環境情報
  * スタックトレース

- 解決プロセスの記録
  * 試行錯誤の過程
  * 最終的な解決策
  * 検証結果
  * 再発防止策

- Source Control連携
  * Issue Branchの名前を記録
  * 各試行段階のコミットハッシュを記録
  * 最終解決のPR番号を記載
  * 関連する一連のコミット履歴を明記

#### Issue間の関連付け
- 関連するIssueの参照
  * 形式: `関連: [ISSUE-NNN]`
  * 複数の場合: `関連: [ISSUE-NNN], [ISSUE-MMM]`

- 継続的な問題の場合
  * 前のIssueへの参照
  * 経緯の要約
  * 新たな知見の記録

#### 状態管理
- 実装状態の記録
  * `[ ]` 未着手
  * `[x]` 完了
  * 日付を含めた進捗記録

- 検証状態の記録
  * テスト結果
  * 再現性の確認
  * 副作用の有無

### 3.6 context-flow.md
- プロセスフローの視覚化
  * プロジェクト初期化フロー
  * エラー解決フロー
  * ドキュメント更新フロー
  * 文脈保持の相互関係
  * Source Control連携フロー
- 更新タイミング
  * ドキュメント管理プロセスの変更時
  * 新しいフローの追加時
  * 既存フローの修正時
- 図の保守
  * マーメイド記法の一貫性維持
  * フロー間の関係性の明確化
  * 視覚的な分かりやすさの確保

## 4. デバッグログの実装方針

### 4.1 技術解説の管理
1. プログラミング初学者向けの技術解説は @thingstoknow ディレクトリに集約
2. プロジェクト固有でない一般的な技術情報を蓄積
3. 各プロジェクトから必要に応じて参照

### 4.2 デバッグ情報の実装方針
1. **最大限の情報収集を標準とする**
   - プロジェクト開始時から完全なデバッグ情報を実装
   - 段階的な強化ではなく、最初から最大限の情報を収集
   - パフォーマンスへの影響は最小限（文字列操作とファイル書き込みのみ）

2. **必須の収集情報**
   - バイトレベルのデータ状態
   - メモリ上のオブジェクト情報
   - エンコーディング変換の詳細
   - 文字列処理の完全な履歴
   - データ変換の全段階の状態

3. **実装の要件**
   - 構造化されたログ形式を使用
   - 適切なログレベルでの出力
   - コンテキスト情報の付加
   - タイムスタンプと識別子の付与

4. **参照情報**
   - 実装の詳細は @thingstoknow/debugging/understanding-logs.md を参照
   - 各プロジェクトの特性に応じて必要な調整を行う

### 4.3 実装ガイドライン
1. **ログレベルの使用**
   - DEBUG: 詳細なデバッグ情報
   - INFO: 重要な処理の開始と完了
   - WARNING: 潜在的な問題
   - ERROR: エラー状態

2. **パフォーマンスへの配慮**
   - 最小限のリソース使用
   - 効率的なログローテーション
   - 適切なログレベルの使用

3. **運用上の注意点**
   - 機密情報のマスキング
   - ログの保持期間の設定
   - ディスク使用量の監視

## 5. エラー解決手順

1. **エラーの評価**
   - 重要度の判断（影響範囲、ビジネスへの影響）
   - 緊急度の判断（即時対応の必要性）
   - 優先順位の決定

2. **問題の分解**
   - 問題を小さな単位に分解する
   - 各単位を順番に解決し、解決ごとに検証を行う

3. **解決策の説明**
   - 現在の挙動を明確にする
   - 望ましい挙動を定義する
   - 両者のギャップを埋めるための手順を説明する

4. **エラー原因の仮説**
   - エラーの原因について仮説を立てる
   - 仮説に基づいた修正を実施し、テストを行う
   - 予期しない結果が出た場合は分析し、仮説を修正して繰り返す

5. **解決と検証**
   - 解決策を実装する
   - テストにより検証する
   - 必要に応じて手順2-4を繰り返す

6. **文書化と共有**
   - ISSUES.mdに解決プロセスを記録
   - 必要に応じてCORE.mdを更新
   - 再発防止策を文書化

## 6. 仮想環境管理

### 6.1 仮想環境の配置
- 仮想環境は `/Users/ete/venvs` に集中管理
- プロジェクトごとに個別の仮想環境を作成
- プロジェクト名をベースとした仮想環境名の使用

### 6.2 仮想環境の命名規則
- 形式: `プロジェクト名-venv`
- 例: HashtagGenerator プロジェクトの場合 → `hashtaggenerator-venv`

### 6.3 仮想環境の管理方針
- requirements.txt による依存関係の管理
- プロジェクトディレクトリ内には仮想環境を作成しない
- 各プロジェクトの CORE.md に使用している仮想環境の情報を記録

## 7. Source Control連携のベストプラクティス

### 7.1 コミット参照の記録方法
- コミットハッシュは短縮形を使用 (例: 1a2b3c4)
- PRは#記号付きで参照 (例: PR #123)
- Issueは#記号付きで参照 (例: Issue #456)
- ブランチ名はバッククォートで囲む (例: `feature/new-feature`)

### 7.2 変更履歴の追跡
- 重要な変更は必ずPRとIssueを紐付ける
- 試行錯誤の過程も含めて各段階のコミットを記録
- 関連する一連の変更をグループ化して記録

### 7.3 参照優先順位
1. ISSUES.md（類似エラーの検索）
2. CORE.md（システム構造の確認）
3. 環境設定（関連設定の確認）

### 7.4 通常時の参照順序
1. CORE.md（最新のシステム状態）
2. 設計判断（アーキテクチャの意図）
3. context-flow.md（プロセスの確認）